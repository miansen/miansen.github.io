---
layout: post
title: SpringBoot 项目为什么没有 web.xml
date: 2019-06-11
categories: SpringBoot
tags: SpringBoot web.xml
author: 龙德
---

* content
{:toc}

## 前言

SpringBoot 的出现极大的简化了我们的开发流程，细心地同学可能会发现，SpringBoot 是没有 web.xml 的，那么 Servlet、 Filter 和 Listener 等繁琐的 web 的相关配置，SpringBoot 是用什么替代的呢？

这个问题不难回答，Servlet、Filter 和 Listener 并不会凭空的帮我们自动配好，SpringBoot 既然抛弃了 web.xml，那么它肯定是在代码里提供了配置功能的类。

其实开发一个 Java Web 项目，不用 web.xml 配置，并不是 SpringBoot 开创的新特性。早在 Serlvet3.0 之后，我们开发一个 Java Web 项目就可以不用 web.xml 配置了，而 SpringMVC 又是基于 Servlet 的，所以要弄清楚 SpringBoot 是用什么替代 web.xml 的，得先从 Servlet 说起。




## Serlvet3.0 之前的时代

为了让同学们的印象更深刻，一步步的探索 web.xml 消失之谜，我们先回忆一下 N 年前（Serlvet3.0 之前）是怎么开发一个 Java Web 项目的。

**首先新建一个动态的 Java Web 项目**

![image](https://miansen.wang/assets/20190611213218.jpg)

可以看到 Eclipse 自动的帮我们创建了 web.xml 文件

![image](https://miansen.wang/assets/20190611213426.jpg)

**创建 HelloSerlvet**

```
package com.example.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloSerlvet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	public HelloSerlvet() {

	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/plain");
		response.getWriter().println("hello world!");

	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}
```

**创建 HelloFilter**

```
package com.example.filter;

import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class HelloFilter implements Filter {

	public HelloFilter() {
		
	}

	public void destroy() {
		
	}

	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		System.out.println("触发 HelloFilter 过滤器");
		chain.doFilter(request, response);
	}

	public void init(FilterConfig fConfig) throws ServletException {

	}

}
```

**在 web.xml 里配置 HelloSerlvet 和 HelloFilter**

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5">
  
  <servlet>
    <description></description>
    <display-name>HelloSerlvet</display-name>
    <servlet-name>HelloSerlvet</servlet-name>
    <servlet-class>com.example.servlet.HelloSerlvet</servlet-class>
  </servlet>
  
  <servlet-mapping>
    <servlet-name>HelloSerlvet</servlet-name>
    <url-pattern>/hello</url-pattern>
  </servlet-mapping>
  
  <filter>
    <display-name>HelloFilter</display-name>
    <filter-name>HelloFilter</filter-name>
    <filter-class>com.example.filter.HelloFilter</filter-class>
  </filter>
  
  <filter-mapping>
    <filter-name>HelloFilter</filter-name>
    <url-pattern>/hello</url-pattern>
  </filter-mapping>
  
</web-app>
```

访问 http://localhost:8080/hello

输出如下

![image](https://miansen.wang/assets/20190611224111.jpg)

过滤器也触发了

![image](https://miansen.wang/assets/20190611224149.jpg)

至此一个 Java Web 的 hello world 就完成了

可以看到仅仅是一个小小的 hello world，都少不了各种配置，如果项目非常大，那可谓是 xml 地狱。

## Servlet3.0 新特性

为了简化开发人员的配置，servlet3.0 提供了  @WebServlet，@WebFilter 等注解和 ServletContainerInitializer 接口，帮助开发人员彻底抛弃 web.xml。

为了便于理解，我们还是以代码来演示。

新建一个动态的 Java Web 项目，web 版本选择 3.1

![image](https://miansen.wang/assets/20190611225531.jpg)

建完后项目结构如下，可以看到，Eclipse 默认帮我们去掉了 web.xml

![image](https://miansen.wang/assets/20190611225608.jpg)

### 基于注解开发 Java Web

**创建 HelloServlet**

```
package com.example.servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/hello")
public class HelloServlet extends HttpServlet {

	private static final long serialVersionUID = 1L;

	public HelloServlet() {

	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		response.setContentType("text/plain");
		response.getWriter().println("hello world!");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}
```

**创建 HelloFilter**

```
package com.example.filter;

import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;

@WebFilter("/hello")
public class HelloFilter implements Filter {

    public HelloFilter() {
        
    }

	public void destroy() {
		
	}


	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		System.out.println("触发 HelloFilter 过滤器");
		chain.doFilter(request, response);
	}

	public void init(FilterConfig fConfig) throws ServletException {
		
	}

}
```

可以看到代码和上面的是一样的，只不过多了 @WebServlet 和 @WebFilter 注解

运行后访问的效果和上面的也是一样的

## 基于接口 ServletContainerInitializer 开发 Java Web

ServletContainerInitializer 是 Servlet 3.0 新增的一个接口，容器在启动时初始化 ServletContainerInitializer 的实现类，以完成 Servlet、Filter 和 Listener 的注册。

声明一个 ServletContainerInitializer 的实现类，web 容器并不会主动识别它，所以，需要借助 SPI 机制来指定该初始化类，这一步骤是通过在项目路径下创建 META-INF/services/javax.servlet.ServletContainerInitializer 来做到的，它只包含一行内容-ServletContainerInitializer 的实现类

`com.example.initializer.ServletContainerInitializer`

![image](https://miansen.wang/assets/20190611231816.jpg)

**创建 ServletContainerInitializer 的实现类 ServletContainerInitializer**