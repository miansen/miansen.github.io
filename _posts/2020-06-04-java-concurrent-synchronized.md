---
layout: post
title: Java 并发之 synchronized
date: 2020-06-04
categories: Java
tags: 并发 synchronized
author: 龙德
---

* content
{:toc}

Java 提供了多线程之间同步的机制，其中最基本的就是使用 synchronization 关键字。这个关键字大家用得比较多，但是可能没仔细梳理过它，这篇博客将仔细梳理 synchronization 关键字，让大家对它有一个更全面和深刻的认识。

想要全面了解 synchronized，得先了解 3 个知识点：Java 内存模型（JMM）、对象的内存布局和 Monitor 对象

## Java 内存模型（JMM）

> 现代多核 CPU 中每个核心拥有自己的一级缓存或一级缓存加上二级缓存等，问题就发生在每个核心的占缓存上。每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值。
>
> Java 作为高级语言，屏蔽了这些底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了主内存和本地内存的概念。
> 
> 所有的共享变量存在于主内存中，每个线程有自己的本地内存，线程读写共享数据也是通过本地内存交换的，所以可见性问题依然是存在的。这里说的本地内存并不是真的是一块给每个线程分配的内存，而是 JMM 的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。

![image](https://camo.githubusercontent.com/2df61e9867d603bd3216c12851b2f7bcaec8847b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545362538442541452545342542382538442545342542382538302545382538372542342e706e67)

总而言之，在 Java 内存模型下，所有的共享变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存保存的是用到的共享变量的主内存副本的拷贝。线程对共享变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。这就可能造成一个线程修改了一个变量的值，而另外一个线程还继续使用它在工作内存中的变量值的拷贝，造成数据的不一致。

那 JMM 跟 synchronized 有什么关系呢？

> 一个线程在获取到监视器锁以后才能进入 synchronized 控制的代码块，一旦进入代码块，首先，该线程对于共享变量的缓存就会失效，因此 synchronized 代码块中对于共享变量的读取需要从主内存中重新获取，也就能获取到最新的值。
> 
> 退出代码块的时候的，会将该线程写在缓冲区中的数据刷到主内存中，所以在 synchronized 代码块之前或 synchronized 代码块中对于共享变量的操作随着该线程退出 synchronized 块，会立即对其他线程可见（这句话的前提是其他读取共享变量的线程会从主内存读取最新值）。

总而言之，当线程进入 synchronized 控制的代码块中，这个线程对共享变量的读取从主内存中获取，退出 synchronized 块，会将修改后的数据刷到主内存中。

## 对象的内存布局

![image](https://pic4.zhimg.com/80/v2-d6ef637c95dd632316155cec75d22557_720w.jpg)

一个 Java 对象在堆内存中包括对象头、实例数据和补齐填充 3 个部分。

对象头包括 Mark Words（存储哈希码、GC分代年龄、锁标志位等）和 Klass Words（指向当前对象所属的类的地址，也就是 Class 对象），如果是数组对象，还有一个保存数组长度的空间。

实例数据是对象真正存储的有效信息，包括了对象的所有成员变量，其大小由各个成员变量的大小共同决定。

对齐填充不是必然存在的，仅仅起占位符的作用。

对象的内存布局跟 synchronized 有什么关系呢？

别着急，下面介绍 synchronized 的使用的时候，会根据对象的内存布局来画图，更加直观的了解 synchronized。现在只需要记住对象头就可以了，对象头的 Mark Words 记录了指向 Monitor 对象的指针，通过它可以关联到 Monitor 对象。

## Monitor 对象

Monitor 其实是对 Java 对象的锁的一种抽象，称为监视器锁。每个对象都有一个 Monitor 相关联，它和 Java 对象是一对一的关系的。我们可以简单的把它理解成一个对象。

Monitor 对象记录了持有锁的线程信息、阻塞队列、等待队列等。既然是对象就会有字段，Monitor 对象主要包含以下三个字段：

- _Owner：记录当前持有锁的线程
- _EntryList：阻塞队列，记录所有阻塞等待锁的线程
- _WaitSet：等待队列，记录调用 wait() 方法并还未被通知的线程

当线程获得对象的监视器锁（Monitor）的时候，线程 id 等信息会拷贝进 _Owner 字段，其余线程会进入阻塞队列 _Entrylist，当持有锁的线程执行 wait() 方法，会立即释放锁进入 _Waitset 队列。当线程释放锁的时候，_Owner 会被置空，然后 _Entrylist 中的线程会竞争锁，竞争成功的线程 id 会写入 _Owner，其余线程继续在 _Entrylist 中等待。

## 参考资料

[https://javadoop.com/post/java-memory-model](https://javadoop.com/post/java-memory-model)

[https://www.cnblogs.com/ZoHy/p/11313155.html](https://www.cnblogs.com/ZoHy/p/11313155.html)

[https://zhuanlan.zhihu.com/p/138427106](https://zhuanlan.zhihu.com/p/138427106)